// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("bs-platform/lib/js/belt_Array.js");

function defaultErrorMessage(stringify, name, value) {
  var valueString = stringify !== undefined ? stringify(value) : "" + value;
  return "Invalid value \"" + valueString + "\" passed to \"" + name + "\"";
}

function getName(validator) {
  return validator.name;
}

function updateName(validator, name) {
  switch (validator.TAG | 0) {
    case /* Validator */0 :
        return {
                TAG: /* Validator */0,
                name: name,
                validate: validator.validate,
                message: validator.message
              };
    case /* AND */1 :
        return {
                TAG: /* AND */1,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* OR */2 :
        return {
                TAG: /* OR */2,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* XOR */3 :
        return {
                TAG: /* XOR */3,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* NOT */4 :
        return {
                TAG: /* NOT */4,
                name: name,
                a: validator.a
              };
    
  }
}

function notName(a) {
  var name = a.name;
  return "NOT[ " + name + " ]";
}

function andName(a, b) {
  var nameA = a.name;
  var nameB = b.name;
  return "AND[ " + nameA + ", " + nameB + " ]";
}

function orName(a, b) {
  var nameA = a.name;
  var nameB = b.name;
  return "OR[ " + nameA + ", " + nameB + " ]";
}

function xorName(a, b) {
  var nameA = a.name;
  var nameB = b.name;
  return "XOR[ " + nameA + ", " + nameB + " ]";
}

function make(name, message, validate) {
  return {
          TAG: /* Validator */0,
          name: name,
          validate: validate,
          message: message !== undefined ? message : (function (value) {
                return defaultErrorMessage(undefined, name, value);
              })
        };
}

function and_(a, b) {
  return {
          TAG: /* AND */1,
          name: andName(a, b),
          a: a,
          b: b
        };
}

function or_(a, b) {
  return {
          TAG: /* OR */2,
          name: orName(a, b),
          a: a,
          b: b
        };
}

function xor(a, b) {
  return {
          TAG: /* XOR */3,
          name: xorName(a, b),
          a: a,
          b: b
        };
}

function not_(a) {
  return {
          TAG: /* NOT */4,
          name: notName(a),
          a: a
        };
}

var Infix = {
  $amp$amp: and_,
  $pipe$pipe: or_,
  $caret$caret: xor,
  not: not_
};

function _makeError(stringify, validator, value) {
  if (validator.TAG === /* Validator */0) {
    return {
            value: value,
            validator: validator,
            validatorName: validator.name,
            message: validator.message(value)
          };
  }
  var name = validator.name;
  return {
          value: value,
          validator: validator,
          validatorName: name,
          message: defaultErrorMessage(stringify, name, value)
        };
}

function _evalSync(_validator, errStackRef, value) {
  while(true) {
    var validator = _validator;
    var errStack = errStackRef.contents;
    var errStackLength = errStack.length;
    switch (validator.TAG | 0) {
      case /* Validator */0 :
          if (validator.validate(value)) {
            return true;
          } else {
            errStack.push(validator);
            return false;
          }
      case /* AND */1 :
          if (_evalSync(validator.a, errStackRef, value) && _evalSync(validator.b, errStackRef, value)) {
            if (errStackLength > 0) {
              errStackRef.contents = [];
            }
            return true;
          } else {
            errStack.push(validator);
            return false;
          }
      case /* OR */2 :
          if (_evalSync(validator.a, errStackRef, value)) {
            if (errStackLength > 0) {
              errStackRef.contents = [];
            }
            return true;
          } else if (_evalSync(validator.b, errStackRef, value)) {
            if (errStackLength > 0) {
              errStackRef.contents = [];
            }
            return true;
          } else {
            errStack.push(validator);
            return false;
          }
      case /* XOR */3 :
          var match = _evalSync(validator.a, errStackRef, value);
          var match$1 = _evalSync(validator.b, errStackRef, value);
          if (match) {
            if (match$1) {
              errStack.push(validator);
              return false;
            } else {
              if (errStackLength > 0) {
                errStackRef.contents = [];
              }
              return true;
            }
          } else if (match$1) {
            if (errStackLength > 0) {
              errStackRef.contents = [];
            }
            return true;
          } else {
            errStack.push(validator);
            return false;
          }
      case /* NOT */4 :
          var a = validator.a;
          switch (a.TAG | 0) {
            case /* Validator */0 :
                if (a.validate(value)) {
                  errStack.push(validator);
                  return false;
                } else {
                  if (errStackLength > 0) {
                    errStackRef.contents = [];
                  }
                  return true;
                }
            case /* NOT */4 :
                _validator = a.a;
                continue ;
            default:
              if (_evalSync(a, errStackRef, value)) {
                errStack.push(validator);
                return false;
              } else {
                if (errStackLength > 0) {
                  errStackRef.contents = [];
                }
                return true;
              }
          }
      
    }
  };
}

function validate(stringify, validator, value) {
  var errStackRef = {
    contents: []
  };
  var errors = [];
  var result = _evalSync(validator, errStackRef, value);
  if (result) {
    return {
            TAG: /* Ok */0,
            _0: value
          };
  }
  var errStack = errStackRef.contents;
  Belt_Array.forEachU(errStack, (function (v) {
          errors.push(_makeError(stringify, v, value));
          
        }));
  return {
          TAG: /* Error */1,
          _0: {
            value: value,
            validatorName: validator.name,
            validator: validator,
            errors: errors
          }
        };
}

function getName$1(validator) {
  return validator.name;
}

function rename(validator, name) {
  switch (validator.TAG | 0) {
    case /* Validator_Async */0 :
        return {
                TAG: /* Validator_Async */0,
                name: name,
                validate: validator.validate,
                message: validator.message
              };
    case /* AND_Async */1 :
        return {
                TAG: /* AND_Async */1,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* OR_Async */2 :
        return {
                TAG: /* OR_Async */2,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* XOR_Async */3 :
        return {
                TAG: /* XOR_Async */3,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* NOT_Async */4 :
        return {
                TAG: /* NOT_Async */4,
                name: name,
                a: validator.a
              };
    
  }
}

var Async = {
  getName: getName$1,
  rename: rename
};

var Impl = {
  defaultErrorMessage: defaultErrorMessage,
  getName: getName,
  updateName: updateName,
  notName: notName,
  andName: andName,
  orName: orName,
  xorName: xorName,
  make: make,
  and_: and_,
  or_: or_,
  xor: xor,
  not_: not_,
  Infix: Infix,
  _makeError: _makeError,
  _evalSync: _evalSync,
  validate: validate,
  Async: Async
};

exports.Impl = Impl;
exports.defaultErrorMessage = defaultErrorMessage;
exports.getName = getName;
exports.updateName = updateName;
exports.notName = notName;
exports.andName = andName;
exports.orName = orName;
exports.xorName = xorName;
exports.make = make;
exports.and_ = and_;
exports.or_ = or_;
exports.xor = xor;
exports.not_ = not_;
exports.Infix = Infix;
exports._makeError = _makeError;
exports._evalSync = _evalSync;
exports.validate = validate;
exports.Async = Async;
/* No side effect */
