// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("bs-platform/lib/js/belt_Array.js");

function defaultErrorMessage(stringify, name, value) {
  var valueString = stringify !== undefined ? stringify(value) : "" + value;
  return "Invalid value \"" + valueString + "\" passed to \"" + name + "\"";
}

function getName(validator) {
  return validator.name;
}

function updateName(validator, name) {
  switch (validator.TAG | 0) {
    case /* Validator */0 :
        return {
                TAG: /* Validator */0,
                name: name,
                validate: validator.validate,
                message: validator.message
              };
    case /* AND */1 :
        return {
                TAG: /* AND */1,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* OR */2 :
        return {
                TAG: /* OR */2,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* XOR */3 :
        return {
                TAG: /* XOR */3,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* NOT */4 :
        return {
                TAG: /* NOT */4,
                name: name,
                a: validator.a
              };
    
  }
}

function notName(a) {
  var name = a.name;
  return "NOT[ " + name + " ]";
}

function andName(a, b) {
  var nameA = a.name;
  var nameB = b.name;
  return "AND[ " + nameA + ", " + nameB + " ]";
}

function orName(a, b) {
  var nameA = a.name;
  var nameB = b.name;
  return "OR[ " + nameA + ", " + nameB + " ]";
}

function xorName(a, b) {
  var nameA = a.name;
  var nameB = b.name;
  return "XOR[ " + nameA + ", " + nameB + " ]";
}

function make(name, message, validate) {
  return {
          TAG: /* Validator */0,
          name: name,
          validate: validate,
          message: message !== undefined ? message : (function (value) {
                return defaultErrorMessage(undefined, name, value);
              })
        };
}

function and_(a, b) {
  return {
          TAG: /* AND */1,
          name: andName(a, b),
          a: a,
          b: b
        };
}

function or_(a, b) {
  return {
          TAG: /* OR */2,
          name: orName(a, b),
          a: a,
          b: b
        };
}

function xor(a, b) {
  return {
          TAG: /* XOR */3,
          name: xorName(a, b),
          a: a,
          b: b
        };
}

function not_(a) {
  return {
          TAG: /* NOT */4,
          name: notName(a),
          a: a
        };
}

function andU(a, b) {
  return {
          TAG: /* AND */1,
          name: andName(a, b),
          a: a,
          b: b
        };
}

function orU(a, b) {
  return {
          TAG: /* OR */2,
          name: orName(a, b),
          a: a,
          b: b
        };
}

function xorU(a, b) {
  return {
          TAG: /* XOR */3,
          name: xorName(a, b),
          a: a,
          b: b
        };
}

function notU(a) {
  return {
          TAG: /* NOT */4,
          name: notName(a),
          a: a
        };
}

var Infix = {
  $amp$amp: and_,
  $pipe$pipe: or_,
  $caret$caret: xor,
  not: not_
};

function _makeError(stringify, validator, value) {
  if (validator.TAG === /* Validator */0) {
    return {
            value: value,
            validator: validator,
            name: validator.name,
            message: validator.message(value)
          };
  }
  var name = validator.name;
  return {
          value: value,
          validator: validator,
          name: name,
          message: defaultErrorMessage(stringify, name, value)
        };
}

function _evalSync(resultsDict, errStackRef, value, validator) {
  var errStack = errStackRef.contents;
  switch (validator.TAG | 0) {
    case /* Validator */0 :
        var name = validator.name;
        if (validator.validate(value)) {
          resultsDict[name] = true;
          return true;
        } else {
          resultsDict[name] = false;
          errStack[errStack.length] = validator;
          return false;
        }
    case /* AND */1 :
        var name$1 = validator.name;
        if (_evalSync(resultsDict, errStackRef, value, validator.a)) {
          if (_evalSync(resultsDict, errStackRef, value, validator.b)) {
            if (errStack.length !== 0) {
              errStackRef.contents = [];
            }
            resultsDict[name$1] = true;
            return true;
          } else {
            errStack[errStack.length] = validator;
            resultsDict[name$1] = false;
            return false;
          }
        } else {
          errStack[errStack.length] = validator;
          resultsDict[name$1] = false;
          return false;
        }
    case /* OR */2 :
        var name$2 = validator.name;
        if (_evalSync(resultsDict, errStackRef, value, validator.a)) {
          if (errStack.length !== 0) {
            errStackRef.contents = [];
          }
          resultsDict[name$2] = true;
          return true;
        } else if (_evalSync(resultsDict, errStackRef, value, validator.b)) {
          if (errStack.length !== 0) {
            errStackRef.contents = [];
          }
          resultsDict[name$2] = true;
          return true;
        } else {
          errStack[errStack.length] = validator;
          resultsDict[name$2] = false;
          return false;
        }
    case /* XOR */3 :
        var name$3 = validator.name;
        var match = _evalSync(resultsDict, errStackRef, value, validator.a);
        var match$1 = _evalSync(resultsDict, errStackRef, value, validator.b);
        if (match) {
          if (match$1) {
            errStack[errStack.length] = validator;
            resultsDict[name$3] = false;
            return false;
          } else {
            if (errStack.length !== 0) {
              errStackRef.contents = [];
            }
            resultsDict[name$3] = true;
            return true;
          }
        } else if (match$1) {
          if (errStack.length !== 0) {
            errStackRef.contents = [];
          }
          resultsDict[name$3] = true;
          return true;
        } else {
          errStack[errStack.length] = validator;
          resultsDict[name$3] = false;
          return false;
        }
    case /* NOT */4 :
        var a = validator.a;
        var name$4 = validator.name;
        switch (a.TAG | 0) {
          case /* Validator */0 :
              if (a.validate(value)) {
                errStack[errStack.length] = validator;
                resultsDict[name$4] = false;
                return false;
              } else {
                if (errStack.length !== 0) {
                  errStackRef.contents = [];
                }
                resultsDict[name$4] = true;
                return true;
              }
          case /* NOT */4 :
              var res = _evalSync(resultsDict, errStackRef, value, a.a);
              resultsDict[name$4] = res;
              return res;
          default:
            if (_evalSync(resultsDict, errStackRef, value, a)) {
              errStack[errStack.length] = validator;
              resultsDict[name$4] = false;
              return false;
            } else {
              if (errStack.length !== 0) {
                errStackRef.contents = [];
              }
              resultsDict[name$4] = true;
              return true;
            }
        }
    
  }
}

function validate(stringify, validator, value) {
  var name = validator.name;
  var errStackRef = {
    contents: []
  };
  var resultsDict = {};
  var result = _evalSync(resultsDict, errStackRef, value, validator);
  if (result) {
    return {
            TAG: /* Ok */0,
            _0: {
              value: value,
              name: name,
              validator: validator,
              errorsArray: [],
              errorsDict: {},
              resultTree: undefined
            }
          };
  }
  var errorsArray = [];
  var errorsDict = {};
  var errStack = errStackRef.contents;
  var errorsIndexRef = 0;
  for(var i = 0 ,i_finish = errStack.length; i < i_finish; ++i){
    var errorsIndex = errorsIndexRef;
    var v = Belt_Array.get(errStack, i);
    if (v !== undefined) {
      var currentError = _makeError(stringify, v, value);
      errorsArray[errorsIndex] = currentError;
      errorsDict[v.name] = currentError;
      errorsIndexRef = errorsIndexRef + 1 | 0;
    }
    
  }
  return {
          TAG: /* Error */1,
          _0: {
            value: value,
            name: name,
            validator: validator,
            errorsArray: errorsArray,
            errorsDict: errorsDict,
            resultTree: undefined
          }
        };
}

function getName$1(validator) {
  return validator.name;
}

function rename(validator, name) {
  switch (validator.TAG | 0) {
    case /* Validator_Async */0 :
        return {
                TAG: /* Validator_Async */0,
                name: name,
                validate: validator.validate,
                message: validator.message
              };
    case /* AND_Async */1 :
        return {
                TAG: /* AND_Async */1,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* OR_Async */2 :
        return {
                TAG: /* OR_Async */2,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* XOR_Async */3 :
        return {
                TAG: /* XOR_Async */3,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* NOT_Async */4 :
        return {
                TAG: /* NOT_Async */4,
                name: name,
                a: validator.a
              };
    
  }
}

var Async = {
  getName: getName$1,
  rename: rename
};

var Impl = {
  defaultErrorMessage: defaultErrorMessage,
  getName: getName,
  updateName: updateName,
  notName: notName,
  andName: andName,
  orName: orName,
  xorName: xorName,
  make: make,
  and_: and_,
  or_: or_,
  xor: xor,
  not_: not_,
  andU: andU,
  orU: orU,
  xorU: xorU,
  notU: notU,
  Infix: Infix,
  _makeError: _makeError,
  _evalSync: _evalSync,
  validate: validate,
  Async: Async
};

exports.Impl = Impl;
exports.defaultErrorMessage = defaultErrorMessage;
exports.getName = getName;
exports.updateName = updateName;
exports.notName = notName;
exports.andName = andName;
exports.orName = orName;
exports.xorName = xorName;
exports.make = make;
exports.and_ = and_;
exports.or_ = or_;
exports.xor = xor;
exports.not_ = not_;
exports.andU = andU;
exports.orU = orU;
exports.xorU = xorU;
exports.notU = notU;
exports.Infix = Infix;
exports._makeError = _makeError;
exports._evalSync = _evalSync;
exports.validate = validate;
exports.Async = Async;
/* No side effect */
