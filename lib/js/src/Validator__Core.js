// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");

function getName(validator) {
  if (validator.TAG === /* Validator */0) {
    return validator._0.name;
  } else {
    return validator.name;
  }
}

function rename(validator, name) {
  switch (validator.TAG | 0) {
    case /* Validator */0 :
        return {
                TAG: /* Validator */0,
                _0: {
                  name: name,
                  validate: validator._0.validate
                }
              };
    case /* AND */1 :
        return {
                TAG: /* AND */1,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* OR */2 :
        return {
                TAG: /* OR */2,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* XOR */3 :
        return {
                TAG: /* XOR */3,
                name: name,
                a: validator.a,
                b: validator.b
              };
    case /* NOT */4 :
        return {
                TAG: /* NOT */4,
                name: name,
                a: validator.a
              };
    
  }
}

function notName(a) {
  var name = getName(a);
  return "NOT[" + name + "]";
}

function andName(a, b) {
  var nameA = getName(a);
  var nameB = getName(b);
  return "AND[" + nameA + "," + nameB + "]";
}

function orName(a, b) {
  var nameA = getName(a);
  var nameB = getName(b);
  return "OR[" + nameA + "," + nameB + "]";
}

function xorName(a, b) {
  var nameA = getName(a);
  var nameB = getName(b);
  return "XOR[" + nameA + "," + nameB + "]";
}

function make(v) {
  return {
          TAG: /* Validator */0,
          _0: v
        };
}

function and_(a, b) {
  return {
          TAG: /* AND */1,
          name: andName(a, b),
          a: a,
          b: b
        };
}

function or_(a, b) {
  return {
          TAG: /* OR */2,
          name: orName(a, b),
          a: a,
          b: b
        };
}

function xor(a, b) {
  return {
          TAG: /* XOR */3,
          name: xorName(a, b),
          a: a,
          b: b
        };
}

function not_(a) {
  return {
          TAG: /* NOT */4,
          name: notName(a),
          a: a
        };
}

function passedButNegated(name, value) {
  return "NOT[" + name + "]: The input value \"" + value + "\" passed \"" + name + "\", but was negated by the \"NOT\" operator.";
}

function failedButNegated(name, value) {
  return "NOT[" + name + "]: The input value \"" + value + "\" failed \"" + name + "\", but was negated by the \"NOT\" operator.";
}

function doubleNegated(name, value) {
  return "NOT[NOT[" + name + "]]: The input value \"" + value + "\" failed \"" + name + "\", and was negated twice by the \"NOT\" operator.";
}

var Not = {
  passedButNegated: passedButNegated,
  failedButNegated: failedButNegated,
  doubleNegated: doubleNegated
};

function leftButNotRight(left, right, value) {
  return "AND[" + left + "," + right + "]: The input value \"" + value + "\" passed \"" + left + "\" but failed \"" + right + "\". ";
}

function rightButNotLeft(left, right, value) {
  return "AND[" + left + "," + right + "]: The input value \"" + value + "\" passed \"" + right + "\" but failed \"" + left + "\". ";
}

function neitherLeftNorRight(left, right, value) {
  return "AND[" + left + "," + right + "]: The input value \"" + value + "\" failed both \"" + left + "\" and \"" + right + "\".";
}

var And = {
  leftButNotRight: leftButNotRight,
  rightButNotLeft: rightButNotLeft,
  neitherLeftNorRight: neitherLeftNorRight
};

function neitherLeftNorRight$1(left, right, value) {
  return "OR[" + left + "," + right + "]: The input value \"" + value + "\" failed both \"" + left + "\" and \"" + right + "\".";
}

var Or = {
  neitherLeftNorRight: neitherLeftNorRight$1
};

function passedLeftAndRight(left, right, value) {
  return "XOR[" + left + "," + right + "]: The input value \"" + value + "\" passed both \"" + left + "\" and \"" + right + "\".";
}

function failedLeftAndRight(left, right, value) {
  return "XOR[" + left + "," + right + "]: The input value \"" + value + "\" failed both \"" + left + "\" and \"" + right + "\".";
}

var Xor = {
  passedLeftAndRight: passedLeftAndRight,
  failedLeftAndRight: failedLeftAndRight
};

var Msg = {
  Not: Not,
  And: And,
  Or: Or,
  Xor: Xor
};

function __evalSync(report, validator, value) {
  switch (validator.TAG | 0) {
    case /* Validator */0 :
        var match = validator._0;
        var name = match.name;
        var error = Curry._1(match.validate, value);
        if (error) {
          report.failed.push({
                name: name,
                value: value,
                message: error._0
              });
          return error;
        } else {
          report.passed.push(name);
          return /* Pass */0;
        }
    case /* AND */1 :
        var b = validator.b;
        var a = validator.a;
        var name$1 = validator.name;
        var match$1 = __evalSync(report, a, value);
        var match$2 = __evalSync(report, b, value);
        if (match$1) {
          if (match$2) {
            var message = neitherLeftNorRight(getName(a), getName(b), value);
            report.failed.push({
                  name: name$1,
                  value: value,
                  message: message
                });
            return /* Fail */{
                    _0: message
                  };
          }
          var message$1 = rightButNotLeft(getName(a), getName(b), value);
          report.failed.push({
                name: name$1,
                value: value,
                message: message$1
              });
          return /* Fail */{
                  _0: message$1
                };
        }
        if (match$2) {
          var message$2 = leftButNotRight(getName(a), getName(b), value);
          report.failed.push({
                name: name$1,
                value: value,
                message: message$2
              });
          return /* Fail */{
                  _0: message$2
                };
        }
        report.passed.push(name$1);
        return /* Pass */0;
    case /* OR */2 :
        var b$1 = validator.b;
        var a$1 = validator.a;
        var name$2 = validator.name;
        var match$3 = __evalSync(report, a$1, value);
        var match$4 = __evalSync(report, b$1, value);
        if (match$3) {
          if (match$4) {
            var message$3 = neitherLeftNorRight$1(getName(a$1), getName(b$1), value);
            report.failed.push({
                  name: name$2,
                  value: value,
                  message: message$3
                });
            return /* Fail */{
                    _0: message$3
                  };
          }
          report.passed.push(name$2);
          return /* Pass */0;
        }
        report.passed.push(name$2);
        return /* Pass */0;
    case /* XOR */3 :
        var b$2 = validator.b;
        var a$2 = validator.a;
        var name$3 = validator.name;
        var match$5 = __evalSync(report, a$2, value);
        var match$6 = __evalSync(report, b$2, value);
        if (match$5) {
          if (match$6) {
            var message$4 = failedLeftAndRight(getName(a$2), getName(b$2), value);
            report.failed.push({
                  name: name$3,
                  value: value,
                  message: message$4
                });
            return /* Fail */{
                    _0: message$4
                  };
          }
          report.passed.push(name$3);
          return /* Pass */0;
        }
        if (match$6) {
          report.passed.push(name$3);
          return /* Pass */0;
        }
        var message$5 = passedLeftAndRight(getName(a$2), getName(b$2), value);
        report.failed.push({
              name: name$3,
              value: value,
              message: message$5
            });
        return /* Fail */{
                _0: message$5
              };
    case /* NOT */4 :
        var a$3 = validator.a;
        var name$4 = validator.name;
        switch (a$3.TAG | 0) {
          case /* Validator */0 :
              var match$7 = a$3._0;
              var match$8 = Curry._1(match$7.validate, value);
              if (match$8) {
                report.passed.push(name$4);
                return /* Pass */0;
              }
              var message$6 = passedButNegated(match$7.name, value);
              report.failed.push({
                    name: name$4,
                    value: value,
                    message: message$6
                  });
              return /* Fail */{
                      _0: message$6
                    };
          case /* NOT */4 :
              var innerValidator = a$3.a;
              var match$9 = __evalSync(report, innerValidator, value);
              if (match$9) {
                var message$7 = doubleNegated(getName(innerValidator), value);
                report.failed.push({
                      name: name$4,
                      value: value,
                      message: message$7
                    });
                return /* Fail */{
                        _0: message$7
                      };
              }
              report.passed.push(name$4);
              return /* Pass */0;
          default:
            var match$10 = __evalSync(report, a$3, value);
            if (match$10) {
              report.passed.push(name$4);
              return /* Pass */0;
            }
            var message$8 = passedButNegated(getName(a$3), value);
            report.failed.push({
                  name: name$4,
                  value: value,
                  message: message$8
                });
            return /* Fail */{
                    _0: message$8
                  };
        }
    
  }
}

function evalSync(validator, value) {
  var mutReport = {
    value: value,
    name: getName(validator),
    isValid: true,
    passed: [],
    failed: []
  };
  var result = __evalSync(mutReport, validator, value);
  if (result) {
    mutReport.isValid = false;
    return {
            TAG: /* Error */1,
            _0: mutReport
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: mutReport
          };
  }
}

var Infix = {
  $amp$amp: and_,
  $pipe$pipe: or_,
  $caret$caret: xor,
  not: not_
};

var Impl = {
  getName: getName,
  rename: rename,
  notName: notName,
  andName: andName,
  orName: orName,
  xorName: xorName,
  make: make,
  and_: and_,
  or_: or_,
  xor: xor,
  not_: not_,
  Msg: Msg,
  __evalSync: __evalSync,
  evalSync: evalSync,
  Infix: Infix
};

exports.Impl = Impl;
exports.getName = getName;
exports.rename = rename;
exports.notName = notName;
exports.andName = andName;
exports.orName = orName;
exports.xorName = xorName;
exports.make = make;
exports.and_ = and_;
exports.or_ = or_;
exports.xor = xor;
exports.not_ = not_;
exports.Msg = Msg;
exports.__evalSync = __evalSync;
exports.evalSync = evalSync;
exports.Infix = Infix;
/* No side effect */
